#!/usr/bin/env bash

set -Eeuo pipefail

red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
nc='\033[0m'

# Get dotfiles dir (so run this script from anywhere)
export dotfiles_dir
dotfiles_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd .. && pwd )"

help() {
    echo "Dotfiles management"
    echo
    echo -e "Usage: ${yellow}$0 <command>${nc}"
    echo
    echo "Commands:"
    echo " help:    This help message"
    echo " update:  Update dotfiles"
    echo " edit:    Open dotfiles directory for editing"
    echo
}

pull_dotfiles() {
    cd "$dotfiles_dir"
    if ! out=$(2>&1 git pull --all --prune --rebase); then
        echo -e "${red}Error updating dotfiles checkout. Fix it and run update again${nc}"
        echo "Output:"
        echo "$out"
        exit 1;
    fi
}

setup_gitconfig() {
  if ! [ -f git/gitconfig.local.symlink ]; then
    create_key=false

    if ! [ -f $HOME/.ssh/id_ed25519 ]; then
        echo -e "${yellow}No ssh key found. Will create a new one if you continue${nc}"
        echo ""
        read -p "Abort with cmd-c, press any key to continue" -n1 -s
        create_key=true
    fi

    echo -e "${yellow}What is your git author name?${nc}"
    read -e git_authorname
    echo -e "${yellow}What is your git author email?${nc}"
    read -e git_authoremail

    if [ "$create_key" = "true" ]; then
        ssh-keygen -t ed25519 -C "$git_authoremail"
    fi

    cat <<INI > git/gitconfig.local.symlink
[user]
        name = $git_authorname
        email = $git_authoremail
        signingkey = $HOME/.ssh/id_ed25519
INI
  fi
}

link_file() {
  local src=$1 dst=$2

  local overwrite= backup= skip=
  local action=

  if [ -f "$dst" -o -d "$dst" -o -L "$dst" ]
  then

    if [ "$overwrite_all" == "false" ] && [ "$backup_all" == "false" ] && [ "$skip_all" == "false" ]
    then

      local currentSrc="$(readlink $dst)"

      if [ "$currentSrc" == "$src" ]
      then

        skip=true;

      else
        echo -e "${yellow}File already exists: $dst ($(basename "$src")), what do you want to do?\n\
        [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?${nc}"
        read -sn 1 action

        case "$action" in
          o )
            overwrite=true;;
          O )
            overwrite_all=true;;
          b )
            backup=true;;
          B )
            backup_all=true;;
          s )
            skip=true;;
          S )
            skip_all=true;;
          * )
            ;;
        esac

      fi

    fi

    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [ "$overwrite" == "true" ]
    then
      echo rm -rf "$dst"
    fi

    if [ "$backup" == "true" ]
    then
      echo mv "$dst" "${dst}.backup"
    fi
  fi

  if [ "$skip" != "true" ]
  then
    echo ln -s "$1" "$2"
  fi
}

install_dotfiles() {
  local overwrite_all=false backup_all=false skip_all=false

  for src in $(find -H "$dotfiles_dir" -maxdepth 2 -name '*.symlink' -not -path '*.git*')
  do
    dst="$HOME/.$(basename "${src%.*}")"
    link_file "$src" "$dst"
  done
}

update() {
    pull_dotfiles
    setup_gitconfig
    install_dotfiles

    echo -e "${green}Success! Dotfiles updated${nc}"
}

if [[ $# -eq 0 ]]; then
    help
    exit 0
fi

case $1 in
    "" | "help" | "-h" | "--help")
        help
        ;;
    "edit")
        exec "${EDITOR:-vim}" "$dotfiles_dir"
        ;;
    "update")
        update
        ;;
    *)
        >&2 echo -e "${red}Error: '$command_name' is not a known command${nc}"
        help
        exit 1
        ;;
esac